!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("@protobuf-ts/plugin-framework"),require("path")):"function"==typeof define&&define.amd?define("RootAppServer",["@protobuf-ts/plugin-framework","path"],t):"object"==typeof exports?exports.RootAppServer=t(require("@protobuf-ts/plugin-framework"),require("path")):e.RootAppServer=t(e["@protobuf-ts/plugin-framework"],e.path)}(this,(e,t)=>(()=>{"use strict";var n={30:(e,t)=>{var n;Object.defineProperty(t,"__esModule",{value:!0}),t.CompilerMode=void 0,function(e){e[e.Unknown=0]="Unknown",e[e.Model=1]="Model",e[e.Client=2]="Client",e[e.Server=3]="Server"}(n||(t.CompilerMode=n={}))},42:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.CompilerMode=t.customTimestamp=t.TypeUtils=t.MethodBase=t.TypeBase=t.ServiceMethodBroadcast=t.ServiceMethodVoidBoth=t.ServiceMethodVoidResponse=t.ServiceMethodVoidRequest=t.ServiceMethod=t.ServiceType=t.ClientMethodBroadcast=t.ClientMethodVoidBoth=t.ClientMethodVoidResponse=t.ClientMethodVoidRequest=t.ClientMethod=t.ClientType=t.ClassType=void 0;var i=n(958);Object.defineProperty(t,"ClassType",{enumerable:!0,get:function(){return i.ClassType}});var s=n(727);Object.defineProperty(t,"ClientType",{enumerable:!0,get:function(){return s.ClientType}}),Object.defineProperty(t,"ClientMethod",{enumerable:!0,get:function(){return s.ClientMethod}}),Object.defineProperty(t,"ClientMethodVoidRequest",{enumerable:!0,get:function(){return s.ClientMethodVoidRequest}}),Object.defineProperty(t,"ClientMethodVoidResponse",{enumerable:!0,get:function(){return s.ClientMethodVoidResponse}}),Object.defineProperty(t,"ClientMethodVoidBoth",{enumerable:!0,get:function(){return s.ClientMethodVoidBoth}}),Object.defineProperty(t,"ClientMethodBroadcast",{enumerable:!0,get:function(){return s.ClientMethodBroadcast}});var o=n(349);Object.defineProperty(t,"ServiceType",{enumerable:!0,get:function(){return o.ServiceType}}),Object.defineProperty(t,"ServiceMethod",{enumerable:!0,get:function(){return o.ServiceMethod}}),Object.defineProperty(t,"ServiceMethodVoidRequest",{enumerable:!0,get:function(){return o.ServiceMethodVoidRequest}}),Object.defineProperty(t,"ServiceMethodVoidResponse",{enumerable:!0,get:function(){return o.ServiceMethodVoidResponse}}),Object.defineProperty(t,"ServiceMethodVoidBoth",{enumerable:!0,get:function(){return o.ServiceMethodVoidBoth}}),Object.defineProperty(t,"ServiceMethodBroadcast",{enumerable:!0,get:function(){return o.ServiceMethodBroadcast}});var r=n(977);Object.defineProperty(t,"TypeBase",{enumerable:!0,get:function(){return r.TypeBase}}),Object.defineProperty(t,"MethodBase",{enumerable:!0,get:function(){return r.MethodBase}});var a=n(359);Object.defineProperty(t,"TypeUtils",{enumerable:!0,get:function(){return a.TypeUtils}});var l=n(128);Object.defineProperty(t,"customTimestamp",{enumerable:!0,get:function(){return l.customTimestamp}});var p=n(30);Object.defineProperty(t,"CompilerMode",{enumerable:!0,get:function(){return p.CompilerMode}})},118:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.FileTimestamp=void 0;const i=n(981),s=n(42);class o extends i.FileBase{constructor(){super("./rootsdk/timestamp",s.customTimestamp)}}t.FileTimestamp=o},128:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.customTimestamp=void 0;var i=n(992);Object.defineProperty(t,"customTimestamp",{enumerable:!0,get:function(){return i.customTimestamp}})},134:t=>{t.exports=e},349:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ServiceMethodBroadcast=t.ServiceMethodVoidBoth=t.ServiceMethodVoidResponse=t.ServiceMethodVoidRequest=t.ServiceMethod=t.ServiceType=void 0;const i=n(30),s=n(977);class o extends s.TypeBase{constructor(e,t,n,i,s,o,r){super(e,t.replace("GrpcService","Service"),n),this.methodMap=new Map,this.clientSync=i,this.multiCommunity=s,this.scope=o,this.compilerMode=r,this.serviceName=t,this.interfaceType="I"+this.typeName}toContent(){this.addFileHeaders();const e=Array.from(this.methodMap.values()).map(e=>e.toMethodRegister(this)).filter(e=>e.length>0).join("\n\t"),t=e.length>0?" implements RootServerService":"";let n=`export abstract class ${this.typeName}Base${t} {\n\t`;return n+=Array.from(this.methodMap.values()).map(e=>e.toMethodDefinition(this)).join("\n\t"),e.length>0&&(n+="\n\n\tprivate __register(): UntypedServerMethodDefinition[] {\n\t\treturn [",n+=e,n+="\n\t]}"),n+=`\n\n\tpublic get ServerServiceName(): string {\n\t\treturn "${this.typeName}";\n\t}\n`,n+"\n}\n"}addFileHeaders(){let e=this.multiCommunity?"@rootplatform/server-app-multi":"@rootsdk/server-app",t=this.scope+"/gen-shared";this.compilerMode==i.CompilerMode.Model?this.file.addToImports("./rootsdk/types",{typename:"Void"}):this.file.addToImports(t,{typename:"Void"}),this.file.addToImports(e,{typename:"RootServer"}),this.file.addToImports(e,{typename:"RootServerService"}),this.file.addToImports(e,{typename:"UntypedServerMethodDefinition"}),this.file.addToImports(e,{typename:"rootServer"}),this.clientSync?this.file.addToImports(e,{typename:"Client"}):this.file.addToImports(e,{typename:"ClientContext"}),this.file.addToImports(e,{typename:"BroadcastClientMerged"}),this.file.addToImports(e,{typename:"DeviceContext"})}}t.ServiceType=o;class r extends s.MethodBase{constructor(e,t,n,i,s){super(e,t,n,i),this.clientContext="",this.clientSyncType=s?"Client":"ClientContext"}toMethodRegister(e){const t=e,n=".rootsdk.Void"==this.input.fullType?"":"e, ";let i=[`serviceName: '${t.serviceName}'`,`methodName: '${this.methodName}'`,`funct: (e: ${this.input.typeName}, c: ${this.clientSyncType}) => { return this.${this.name}(${n}c) }`,`path: '${this.path}'`];".rootsdk.Void"==this.input.fullType?i.push("requestDeserialize: bytes => Void.fromBinary(bytes)"):i.push(`requestDeserialize: bytes => ${this.input.typeName}.fromBinary(bytes)`),".rootsdk.Void"==this.output.fullType?i.push("responseSerialize: value => Void.toBinary({})"):i.push(`responseSerialize: value => ${this.output.typeName}.toBinary(value)`);return`\t{\n\t\t\t${i.join(",\n\t\t\t")}\n\t\t},`}}t.ServiceMethod=class extends r{constructor(e,t,n,i,s){super(e,t,n,i,s)}toMethodDefinition(e){return`abstract ${this.name}(request: ${this.input.typeName}, client: ${this.clientSyncType}): Promise<${this.output.typeName}>;`}};t.ServiceMethodVoidRequest=class extends r{constructor(e,t,n,i,s){super(e,t,n,i,s)}toMethodDefinition(e){return`abstract ${this.name}(client: ${this.clientSyncType}): Promise<${this.output.typeName}>;`}};t.ServiceMethodVoidResponse=class extends r{constructor(e,t,n,i,s){super(e,t,n,i,s)}toMethodDefinition(e){return`abstract ${this.name}(request: ${this.input.typeName},client: ${this.clientSyncType}): Promise<void>;`}};t.ServiceMethodVoidBoth=class extends r{constructor(e,t,n,i,s){super(e,t,n,i,s)}toMethodDefinition(e){return`abstract ${this.name}(client: ${this.clientSyncType}): Promise<void>;`}};t.ServiceMethodBroadcast=class extends r{constructor(e,t,n,i,s){super(e,t,n,i,s)}toMethodDefinition(e){return`public ${this.name}(message: ${this.input.typeName}, clients: BroadcastClientMerged, except?: DeviceContext) {\n\t\t(<any>rootServer).sendBroadcast('${this.path}', message, clients, except);\n\t}`}toMethodRegister(e){return`\t{\n\t\t\tserviceName: "${e.serviceName}",\n\t\t\tmethodName: "${this.methodName}",\n      path: '${this.path}',\n      requestSerialize: value => ${this.input.typeName}.toBinary(value)\n    },`}}},359:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.TypeUtils=void 0;class n{static lowerCaseFirstLetter(e){return e.charAt(0).toLowerCase()+e.slice(1)}static camelCase(e){return e.indexOf("_")<0?n.lowerCaseFirstLetter(e):e.toLowerCase().replace(/[^a-zA-Z0-9]+(.)/g,(e,t)=>t.toUpperCase())}}t.TypeUtils=n},401:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.FileIndexClient=void 0;const i=n(981);class s extends i.FileBase{build(){let e={};for(let t of this.clientMap.values())t.filename in e||(e[t.filename]=[]);for(let t in e){const e=this.getRelative(t);this.content+=`export * from "${e}";\n\n`}this.classMap.clear(),this.clientMap.clear()}}t.FileIndexClient=s},461:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.MessageMap=void 0;const i=n(876),s=n(42);t.MessageMap=class{constructor(e){this.clientSync=!0,this.multiCommunity=!1,this.compilerMode=s.CompilerMode.Unknown,this.sharedPackageName="shared",this.isVerbose=!1,this.map=new Map,this.fileMap=new Map,this.request=e;const t=(e.parameter||"").split(",");for(let e of t){const[t,n]=e.split("=");switch(t){case"multi":this.multiCommunity=!0;break;case"verbose":this.isVerbose=!0;break;case"scope":this.scope=n;break;case"shared":this.sharedPackageName=n;break;case"target":switch(n){case"model":this.compilerMode=s.CompilerMode.Model;break;case"client":this.compilerMode=s.CompilerMode.Client;break;case"server":this.compilerMode=s.CompilerMode.Server;break;default:console.error("Unknown target "+n),process.exit(1)}}}this.scope||(console.error("Package name is required argument"),process.exit(1)),this.indexClient=new i.FileIndexClient("index"),this.indexServer=new i.FileIndexServer("index"),this.indexModel=new i.FileIndexModel("index"),this.compilerMode==s.CompilerMode.Client?this.fileMap.set("index",this.indexClient):this.compilerMode==s.CompilerMode.Server?this.fileMap.set("index",this.indexServer):this.compilerMode==s.CompilerMode.Model?this.fileMap.set("index",this.indexModel):(console.error("Unspecified output option, please use opts to specify"),process.exit(1))}addFile(e){this.fileMap.set(e.fullFilename,e)}build(){for(const e of this.request.fileToGenerate){const t=this.request.protoFile.find(t=>t.name==e);if(!t)throw new DOMException(`Unable to find file ${e}`);for(let n of t.messageType){let i="./"+e.replace(/\.proto$/,"");this.compilerMode!=s.CompilerMode.Model&&(i=(this.scope?this.scope+"/":"")+this.sharedPackageName);const o=new s.ClassType(t.package||"",n.name,i);if(this.indexModel.addClass(o),n.nestedType&&n.nestedType.length>0)for(let e of n.nestedType){const o=n.name+"."+e.name,r=new s.ClassType(t.package||"",o,i);this.map.set(r.fullType,r)}this.map.set(o.fullType,o)}}this.map.has(".rootsdk.Timestamp")&&this.compilerMode==s.CompilerMode.Model&&(this.timestamp=new i.FileTimestamp,this.fileMap.set("rootsdk/timestamp",this.timestamp));for(const e of this.request.fileToGenerate){const t=this.request.protoFile.find(t=>t.name==e);if(!t)throw new DOMException(`Unable to find file ${e}`);if(!t.service||0==t.service.length)continue;this.isVerbose&&console.error(e);const n=new i.FileBase("./"+e.replace(".proto",".client")),o=new i.FileBase("./"+e.replace(".proto",".server"));this.compilerMode==s.CompilerMode.Client?this.addFile(n):this.compilerMode==s.CompilerMode.Server&&this.addFile(o);for(let i of t.service)this.isVerbose&&console.error(`${e} ${i.name}`),this.addServiceClient(n,t.package||"",i),this.addServiceServer(o,t.package||"",i)}this.compilerMode==s.CompilerMode.Client?this.indexClient.build():this.compilerMode==s.CompilerMode.Server?this.indexServer.build():this.compilerMode==s.CompilerMode.Model&&this.indexModel.build()}getType(e){if(!e)throw new Error("Missing type name");if(e.startsWith(".google")){if(!this.map.has(e)){const t=e.split("."),n=t[t.length-1],i=new s.ClassType("google.protobuf",n,"./google/protobuf/"+n.toLowerCase());this.map.set(i.fullType,i)}}else if(!this.map.has(e))throw new Error("Unable to find type "+e);return this.map.get(e)}isBroadcast(e,t,n){if(!e.name.startsWith("Broadcast"))return!1;if(".rootsdk.Void"==t.fullType)throw new Error("Unable to broadcast with a rootsdk.Void value");if(".rootsdk.Void"!=n.fullType)throw new Error("Unable to broadcast response other than rootsdk.Void");return!0}addServiceClient(e,t,n){const i=new s.ClientType(t,n.name+"Client",e,this.scope,this.compilerMode),o="/"+t+"."+n.name+"/";e.clientMap.set(i.fullType,i);for(let t of n.method){const n=this.getType(t.inputType),r=this.getType(t.outputType);let a;e.addImportHeader(n),e.addImportHeader(r),this.indexClient.clientMap.set(i.fullType,i),this.isBroadcast(t,n,r)?(a=new s.ClientMethodBroadcast(t.name,o+t.name,n,r),this.indexClient.addClass(n)):".rootsdk.Void"==n.fullType&&".rootsdk.Void"==r.fullType?a=new s.ClientMethodVoidBoth(t.name,o+t.name,n,r):".rootsdk.Void"==n.fullType?(a=new s.ClientMethodVoidRequest(t.name,o+t.name,n,r),this.indexClient.addClass(r)):".rootsdk.Void"==r.fullType?(a=new s.ClientMethodVoidResponse(t.name,o+t.name,n,r),this.indexClient.addClass(n)):(a=new s.ClientMethod(t.name,o+t.name,n,r),this.indexClient.addClass(n),this.indexClient.addClass(r)),i.methodMap.set(a.name,a)}}addServiceServer(e,t,n){const i=new s.ServiceType(t,n.name,e,this.clientSync,this.multiCommunity,this.scope,this.compilerMode),o="/"+t+"."+n.name+"/";e.serviceMap.set(i.fullType,i);for(let t of n.method){if(t.clientStreaming)throw new Error("rootsdk Protobuf does not support client streaming. TODO see the docs.");if(t.serverStreaming)throw new Error("rootsdk Protobuf does not support server streaming. TODO see the docs.");const n=this.getType(t.inputType),r=this.getType(t.outputType);let a;e.addImportHeader(n),e.addImportHeader(r),this.indexServer.serviceMap.set(i.fullType,i),this.isBroadcast(t,n,r)?(a=new s.ServiceMethodBroadcast(t.name,o+t.name,n,r,this.clientSync),this.indexServer.addClass(n)):".rootsdk.Void"==n.fullType&&".rootsdk.Void"==r.fullType?a=new s.ServiceMethodVoidBoth(t.name,o+t.name,n,r,this.clientSync):".rootsdk.Void"==n.fullType?(a=new s.ServiceMethodVoidRequest(t.name,o+t.name,n,r,this.clientSync),this.indexServer.addClass(r)):".rootsdk.Void"==r.fullType?(a=new s.ServiceMethodVoidResponse(t.name,o+t.name,n,r,this.clientSync),this.indexServer.addClass(n)):(a=new s.ServiceMethod(t.name,o+t.name,n,r,this.clientSync),this.indexServer.addClass(r),this.indexServer.addClass(n)),i.methodMap.set(a.name,a)}}}},701:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.FileIndexModel=void 0;const i=n(981);class s extends i.FileBase{build(){let e={};for(let t of this.classMap.values())t.filename in e||(e[t.filename]=[]),e[t.filename].push(t.typeName);for(let t in e){const e=this.getRelative(t);this.content+=`export * from "${e}";\n\n`}this.classMap.clear(),this.clientMap.clear()}}t.FileIndexModel=s},727:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ClientMethodBroadcast=t.ClientMethodVoidBoth=t.ClientMethodVoidResponse=t.ClientMethodVoidRequest=t.ClientMethod=t.ClientMethodBase=t.ClientType=void 0;const i=n(977),s=n(30);class o extends i.TypeBase{constructor(e,t,n,i,s){super(e,t.replace("GrpcService",""),n),this.hasEvents=!1,this.methodMap=new Map,this.serviceName=t,this.scope=i,this.compilerMode=s,this.interfaceType="I"+this.typeName+"Client"}addFileHeaders(){const e="@rootsdk/client-app";this.compilerMode==s.CompilerMode.Model?this.file.addToImports("./rootsdk/types",{typename:"Void"}):this.file.addToImports(this.scope+"/gen-shared",{typename:"Void"}),this.file.addToImports(e,{typename:"EventEmitter"}),this.file.addToImports(e,{typename:"IRootClient"}),this.file.addToImports(e,{typename:"RootClientService"}),this.file.addToImports(e,{typename:"TypedEventEmitter"}),this.file.addToImports(e,{typename:"UntypedClientMethodDefinition"}),this.file.addToImports(e,{typename:"rootClient"})}toContent(){this.addFileHeaders();let e="";const t=Array.from(this.methodMap.values()),n=t.filter(e=>e instanceof a);let i="",s="";const o=t.map(e=>e.toMethodRegister(this)).filter(e=>e.length>0).join("\n\t");if(n.length>0){this.hasEvents=!0;const t=n.map(e=>`\t${e.origName} = '${e.name}'`).join(",\n\t"),r=n.map(e=>`\t'${e.name}': (event: ${e.input.typeName}) => void`).join(",\n\t");e+=`export enum ${this.typeName}Event {\n\t${t}\n}\n`,e+=`export type ${this.typeName}Events = {\n\t${r}\n}\n\n`;const a=o.length>0?" implements RootClientService":"";s="  constructor() { super(); }\n",i=`extends (EventEmitter as new() => TypedEventEmitter<${this.typeName}Events>)${a}\n`}const r=this.typeName.charAt(0).toLowerCase()+this.typeName.slice(1);return e+=`export class ${this.typeName} ${i} {\n${s} \n\t`,e+=`public get ClientServiceName(): string {\n\t\treturn "${this.typeName}";\n\t}\n\n  `,e+=t.map(e=>e.toMethodDefinition(this)).join("\n\t"),o.length>0&&(e+="private __register(): UntypedClientMethodDefinition[] {\n\t\treturn [",e+=o,e+="\n\t]}"),e+="\n}\n",e+=`\nexport const ${r} = new ${this.typeName}();\n\n(<IRootClient><unknown>rootClient).addClient(${r});\n\n`,e}}t.ClientType=o;class r extends i.MethodBase{constructor(e,t,n,i){super(e,t,n,i)}toMethodRegister(e){let t=[`serviceName: '${e.serviceName}'`,`methodName: '${this.methodName}'`,`path: '${this.path}'`];".rootsdk.Void"==this.input.fullType?t.push("requestSerialize: () => Void.toBinary({})"):t.push(`requestSerialize: value => ${this.input.typeName}.toBinary(value)`),".rootsdk.Void"==this.output.fullType?t.push("responseDeserialize: () => {}"):t.push(`responseDeserialize: bytes => ${this.output.typeName}.fromBinary(bytes)`);return`\t{\n      ${t.join(",\n\t\t\t")}\n    },`}}t.ClientMethodBase=r;t.ClientMethod=class extends r{constructor(e,t,n,i){super(e,t,n,i)}toMethodDefinition(e){return`${this.name}(request: ${this.input.typeName}):Promise<${this.output.typeName}> {\n\t\treturn (<any>rootClient).sendWithResponse('${this.path}',request, this.${this.name});\n\t}`}};t.ClientMethodVoidRequest=class extends r{constructor(e,t,n,i){super(e,t,n,i)}toMethodDefinition(e){return`${this.name}():Promise<${this.output.typeName}> {\n\t\treturn (<any>rootClient).sendWithResponse('${this.path}',{}, this.${this.name});\n\t}`}};t.ClientMethodVoidResponse=class extends r{constructor(e,t,n,i){super(e,t,n,i)}toMethodDefinition(e){return`${this.name}(request: ${this.input.typeName}):Promise<void> {\n\t\t\t(<any>rootClient).sendWithResponse('${this.path}',request, this.${this.name});\n\t\t\treturn Promise.resolve();\n\t}`}};t.ClientMethodVoidBoth=class extends r{constructor(e,t,n,i){super(e,t,n,i)}toMethodDefinition(e){return`${this.name}(): Promise<void> {\n\t\t\t(<any>rootClient).sendWithResponse('${this.path}',{}, this.${this.name});\n\t\t\treturn Promise.resolve();\n\t}`}};class a extends r{constructor(e,t,n,i){super(e,t,n,i),this.origName=e.replace(/^Broadcast/,"")}toMethodDefinition(e){return""}toMethodRegister(e){return`\t{\n\t\t\tserviceName: "${e.serviceName}",\n      methodName: "${this.methodName}",\n      path: '${this.path}',\n      funct: (e: ${this.input.typeName}) => { this.emit(${e.typeName}Event.${this.origName},e) },\n      responseDeserialize: bytes => ${this.input.typeName}.fromBinary(bytes)\n    },`}}t.ClientMethodBroadcast=a},876:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.FileTimestamp=t.FileIndexModel=t.FileIndexClient=t.FileIndexServer=t.FileBase=void 0;var i=n(981);Object.defineProperty(t,"FileBase",{enumerable:!0,get:function(){return i.FileBase}});var s=n(917);Object.defineProperty(t,"FileIndexServer",{enumerable:!0,get:function(){return s.FileIndexServer}});var o=n(401);Object.defineProperty(t,"FileIndexClient",{enumerable:!0,get:function(){return o.FileIndexClient}});var r=n(701);Object.defineProperty(t,"FileIndexModel",{enumerable:!0,get:function(){return r.FileIndexModel}});var a=n(118);Object.defineProperty(t,"FileTimestamp",{enumerable:!0,get:function(){return a.FileTimestamp}})},911:e=>{e.exports=t},917:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.FileIndexServer=void 0;const i=n(981);class s extends i.FileBase{constructor(){super(...arguments),this.permissionManagerMap=new Map}build(){let e={};for(let t of this.serviceMap.values())t.filename in e||(e[t.filename]=[]);for(let t in e){const e=this.getRelative(t);this.content+=`export * from "${e}";\n\n`}this.classMap.clear(),this.serviceMap.clear()}}t.FileIndexServer=s},958:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ClassType=void 0;const i=n(977);class s extends i.TypeBase{constructor(e,t,n){super(e,t,n),this.propertyMap=new Map}}t.ClassType=s},977:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.MethodBase=t.TypeBase=void 0;const i=n(876),s=n(359);t.TypeBase=class{constructor(e,t,n){this.typeName=t,this.fullType=(e?"."+e:e)+"."+t,n&&(n instanceof i.FileBase?(this.file=n,this.filename=n.fullFilename):this.filename=n)}getImport(){return{name:this.typeName,filename:this.filename}}};t.MethodBase=class{constructor(e,t,n,i){this.methodName=e,this.name=s.TypeUtils.lowerCaseFirstLetter(e),this.path=t,this.input=n,this.output=i}}},981:function(e,t,n){var i,s=this&&this.__createBinding||(Object.create?function(e,t,n,i){void 0===i&&(i=n);var s=Object.getOwnPropertyDescriptor(t,n);s&&!("get"in s?!t.__esModule:s.writable||s.configurable)||(s={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,i,s)}:function(e,t,n,i){void 0===i&&(i=n),e[i]=t[n]}),o=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),r=this&&this.__importStar||(i=function(e){return i=Object.getOwnPropertyNames||function(e){var t=[];for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[t.length]=n);return t},i(e)},function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n=i(e),r=0;r<n.length;r++)"default"!==n[r]&&s(t,e,n[r]);return o(t,e),t});Object.defineProperty(t,"__esModule",{value:!0}),t.FileBase=void 0;const a=r(n(911)),l=n(42);t.FileBase=class{constructor(e,t=null){this._generated=!1,this.imports=new Map,this.extraImports="",this.classMap=new Map,this.clientMap=new Map,this.serviceMap=new Map,this.content="";let n=a.parse(e);this.filename=n.base,this.fullFilename=n.dir+"/"+n.base,this.fullPath=n.dir,t&&(this.content=t)}getContentHeaderBase(){return"// @generated by rootSdk Generator\n// DO NOT HAND EDIT\n// tslint: disable\n\n"}getImportHeaders(){let e="";a.parse(this.fullFilename).dir;for(let[t,n]of this.imports)if(this.fullFilename!=t)if(t.startsWith("@")||"."==t[0]){e+=`import {\n  ${n.types.map(e=>e.typename).sort().join(",\n\t")}\n} from "${t}"\n`}else{const i=a.parse(t),s=i.dir;let o=a.relative(this.fullPath,s);const r=i.base;if(!o&&!r)continue;o||(o=".");e+=`import {\n  ${n.types.map(e=>e.alias?e.typename+" as "+e.alias:e.typename).sort().join(",\n\t")}\n} from "${o}/${r}"\n`}return e+"\n"}addToImports(e,t){if(this.imports.has(e)){const n=this.imports.get(e);n.types.find(e=>e.typename==t.typename)||n.types.push(t)}else this.imports.set(e,{filename:e,types:[t]})}addImportHeader(e,t){if(".rootsdk.Void"==e.fullType)return;const n=e.getImport();if(!n||!n.filename)return;const i={typename:n.name,alias:t};this.addToImports(n.filename,i)}getFilename(){return"./"+this.fullPath+"/"+this.filename+".ts"}_getContent(){this._generated||(this.getServices(),this.getClients()),this._generated=!0}getContent(){return this._getContent(),this.content?this.getContentHeaderBase()+this.extraImports+this.getImportHeaders()+this.content:""}getRelative(e){if(e.startsWith("@"))return e;const t=a.parse("./"+e);return("./"+a.relative("./"+this.fullPath,t.dir)+"/"+t.base).replace(/\/\//,"/")}getClients(){this.content+=Array.from(this.clientMap.values()).map(e=>e.toContent()).join("\n")}getServices(){this.content+=Array.from(this.serviceMap.values()).map(e=>e.toContent()).join("\n")}addClass(e){if(!(e instanceof l.ClassType))throw new Error("Tried adding a class, but wasn't a class {"+typeof e);this.classMap.has(e.fullType)||this.classMap.set(e.fullType,e)}}},992:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.customTimestamp=void 0,t.customTimestamp='\nimport type { BinaryWriteOptions } from "@protobuf-ts/runtime";\nimport type { IBinaryWriter } from "@protobuf-ts/runtime";\nimport { WireType } from "@protobuf-ts/runtime";\nimport type { BinaryReadOptions } from "@protobuf-ts/runtime";\nimport type { IBinaryReader } from "@protobuf-ts/runtime";\nimport { UnknownFieldHandler } from "@protobuf-ts/runtime";\nimport type { PartialMessage } from "@protobuf-ts/runtime";\nimport { reflectionMergePartial } from "@protobuf-ts/runtime";\nimport { typeofJsonValue } from "@protobuf-ts/runtime";\nimport type { JsonValue } from "@protobuf-ts/runtime";\nimport type { JsonReadOptions } from "@protobuf-ts/runtime";\nimport type { JsonWriteOptions } from "@protobuf-ts/runtime";\nimport { PbLong } from "@protobuf-ts/runtime";\nimport { MessageType } from "@protobuf-ts/runtime";\n\nexport interface Timestamp {\n    /**\n     * Represents seconds of UTC time since Unix epoch\n     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n     * 9999-12-31T23:59:59Z inclusive.\n     *\n     * @generated from protobuf field: int64 seconds = 1;\n     */\n    seconds: bigint;\n    /**\n     * Non-negative fractions of a second at nanosecond resolution. Negative\n     * second values with fractions must still have non-negative nanos values\n     * that count forward in time. Must be from 0 to 999,999,999\n     * inclusive.\n     *\n     * @generated from protobuf field: int32 nanos = 2;\n     */\n    nanos: number;\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass Timestamp$Type extends MessageType<Timestamp> {\n    constructor() {\n        super("rootsdk.Timestamp", [\n            { no: 1, name: "seconds", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 2, name: "nanos", kind: "scalar", T: 5 /*ScalarType.INT32*/ }\n        ]);\n    }\n    /**\n     * Creates a new \'Timestamp\' for the current time.\n     */\n    now(): Timestamp {\n        const msg = this.create();\n        const ms = Date.now();\n        msg.seconds = PbLong.from(Math.floor(ms / 1000)).toBigInt();\n        msg.nanos = (ms % 1000) * 1000000;\n        return msg;\n    }\n    /**\n     * Converts a \'Timestamp\' to a JavaScript Date.\n     */\n    toDate(message: Timestamp): Date {\n        return new Date(PbLong.from(message.seconds).toNumber() * 1000 + Math.ceil(message.nanos / 1000000));\n    }\n    /**\n     * Converts a JavaScript Date to a \'Timestamp\'.\n     */\n    fromDate(date: Date): Timestamp {\n        const msg = this.create();\n        const ms = date.getTime();\n        msg.seconds = PbLong.from(Math.floor(ms / 1000)).toBigInt();\n        msg.nanos = (ms % 1000) * 1000000;\n        return msg;\n    }\n    /**\n     * In JSON format, the \'Timestamp\' type is encoded as a string\n     * in the RFC 3339 format.\n     */\n    internalJsonWrite(message: Timestamp, options: JsonWriteOptions): JsonValue {\n        let ms = PbLong.from(message.seconds).toNumber() * 1000;\n        if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z"))\n            throw new Error("Unable to encode Timestamp to JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.");\n        if (message.nanos < 0)\n            throw new Error("Unable to encode invalid Timestamp to JSON. Nanos must not be negative.");\n        let z = "Z";\n        if (message.nanos > 0) {\n            let nanosStr = (message.nanos + 1000000000).toString().substring(1);\n            if (nanosStr.substring(3) === "000000")\n                z = "." + nanosStr.substring(0, 3) + "Z";\n            else if (nanosStr.substring(6) === "000")\n                z = "." + nanosStr.substring(0, 6) + "Z";\n            else\n                z = "." + nanosStr + "Z";\n        }\n        return new Date(ms).toISOString().replace(".000Z", z);\n    }\n    /**\n     * In JSON format, the \'Timestamp\' type is encoded as a string\n     * in the RFC 3339 format.\n     */\n    internalJsonRead(json: JsonValue, options: JsonReadOptions, target?: Timestamp): Timestamp {\n        if (typeof json !== "string")\n            throw new Error("Unable to parse Timestamp from JSON " + typeofJsonValue(json) + ".");\n        let matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);\n        if (!matches)\n            throw new Error("Unable to parse Timestamp from JSON. Invalid format.");\n        let ms = Date.parse(matches[1] + "-" + matches[2] + "-" + matches[3] + "T" + matches[4] + ":" + matches[5] + ":" + matches[6] + (matches[8] ? matches[8] : "Z"));\n        if (Number.isNaN(ms))\n            throw new Error("Unable to parse Timestamp from JSON. Invalid value.");\n        if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z"))\n            throw new globalThis.Error("Unable to parse Timestamp from JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.");\n        if (!target)\n            target = this.create();\n        target.seconds = PbLong.from(ms / 1000).toBigInt();\n        target.nanos = 0;\n        if (matches[7])\n            target.nanos = (parseInt("1" + matches[7] + "0".repeat(9 - matches[7].length)) - 1000000000);\n        return target;\n    }\n    create(value?: PartialMessage<Timestamp>): Timestamp {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.seconds = 0n;\n        message.nanos = 0;\n        if (value !== undefined)\n            reflectionMergePartial<Timestamp>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Timestamp): Timestamp {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* int64 seconds */ 1:\n                    message.seconds = reader.int64().toBigInt();\n                    break;\n                case /* int32 nanos */ 2:\n                    message.nanos = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === "throw")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Timestamp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* int64 seconds = 1; */\n        if (message.seconds !== 0n)\n            writer.tag(1, WireType.Varint).int64(message.seconds);\n        /* int32 nanos = 2; */\n        if (message.nanos !== 0)\n            writer.tag(2, WireType.Varint).int32(message.nanos);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message rootsdk.Timestamp\n */\nexport const Timestamp = new Timestamp$Type();\n'}},i={};function s(e){var t=i[e];if(void 0!==t)return t.exports;var o=i[e]={exports:{}};return n[e].call(o.exports,o,o.exports,s),o.exports}var o={};return(()=>{var e=o;Object.defineProperty(e,"__esModule",{value:!0}),e.RootTsAppPlugin=void 0;const t=s(134),n=s(461);class i extends t.PluginBase{constructor(){super(...arguments),this.getSupportedFeatures=()=>[t.CodeGeneratorResponse_Feature.PROTO3_OPTIONAL]}async generate(e){return this.messageMap=new n.MessageMap(e),this.messageMap.build(),Array.from(this.messageMap.fileMap.values())}runFactory(e){new e(this.messageMap).build()}}e.RootTsAppPlugin=i})(),o})());